# -*- coding: utf-8 -*-
"""Tutorial3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YU9cQB1B1Bznst10_66CAe2JCf7bdsry
"""

#Basic Filling Algorithm
def fill (x, y, color, color1) :
  if(getpixel(x, y) == 0):
    setpixel(x, y)
    fill(x+1, y)
    fill(x-1, y)
    fill(y+1, x)
    fill(y-1, x)

#Flood Fill Algorithm

def is_valid(screen, m, n, x, y, old_colour, new_colour):
  if(x<0 or x>=m or y<0 or y>= n or screen[x][y]!= old_colour or screen [x][y] == new_colour):
    return False
  return True
    

def flood_fill(screen, m, n, x, y, old_colour, new_colour):
    queue = []

    queue.append([x, y])
    screen[x][y] = new_colour

    while queue:

      current_pixel = queue.pop()

      x_position = current_pixel[0]
      y_position = current_pixel[1]

      if(is_valid(screen, m, n, x_position+1, y_position, old_colour, new_colour)):
        screen[x_position + 1][y_position] = new_colour
        queue.append([x_position+1, y_position])

      if(is_valid(screen, m, n, x_position-1, y_position, old_colour, new_colour)):
        screen[x_position - 1][y_position] = new_colour
        queue.append([x_position-1, y_position])

      if(is_valid(screen, m, n, x_position, y_position+1, old_colour, new_colour)):
        screen[x_position][y_position+1] = new_colour
        queue.append([x_position, y_position+1])

      if(is_valid(screen, m, n, x_position, y_position-1, old_colour, new_colour)):
        screen[x_position][y_position-1] = new_colour
        queue.append([x_position, y_position-1])


def main():
  screen =[
  [1, 1, 1, 1, 1, 1, 1, 1],
  [1, 1, 1, 1, 1, 1, 0, 0],
  [1, 0, 0, 1, 1, 0, 1, 1],
  [1, 2, 2, 2, 2, 0, 1, 0],
  [1, 1, 1, 2, 2, 0, 1, 0],
  [1, 1, 1, 2, 2, 2, 2, 0],
  [1, 1, 1, 1, 1, 2, 1, 1],
  [1, 1, 1, 1, 1, 2, 2, 1],
    ]

  m = len(screen)
  n = len(screen[0])

  x = 4
  y = 4

  old_colour = screen[x][y]
  new_colour = 5

  flood_fill(screen, m, n, x, y, old_colour, new_colour)

  for i in range(m):
    for j in range(n):
      print(screen[i][j], end =' ')
    print()

main()

#Boundary Fill Algorithm

def is_valid(screen, m, n, x, y, fill_colour, border_colour):
  if(x<0 or x>=m or y<0 or y>= n or screen[x][y]!= fill_colour and screen [x][y] != border_colour):
    return False
  return True

def boundary_fill(screen, m, n, x, y, fill_colour, border_colour):
  queue = []
  queue.append([x, y])
  screen[x][y] = border_colour

  while queue:

    current_pixel = queue.pop()
    x_position = current_pixel[0]
    y_position = current_pixel[1]

    if(is_valid(screen, m, n, x_position+1, y_position, fill_colour, border_colour)):
      screen[x_position+1][y_position] = border_colour
      queue.append([x_position, y_position])

    if(is_valid(screen, m, n, x_position-1, y_position, fill_colour, border_colour)):
      screen[x_position-1][y_position] = border_colour
      queue.append([x_position-1, y_position])

    if(is_valid(screen, m, n, x_position, y_position+1, fill_colour, border_colour)):
      screen[x_position][y_position+1] = border_colour
      queue.append([x_position, y_position+1]) 

    if(is_valid(screen, m, n, x_position, y_position-1, fill_colour, border_colour)):
      screen[x_position][y_position+1] = border_colour
      queue.append([x_position, y_position-1])
    

def main():
  screen =[
  [1, 1, 1, 1, 1, 1, 1, 1],
  [1, 1, 1, 1, 1, 1, 0, 0],
  [1, 0, 0, 1, 1, 0, 1, 1],
  [1, 2, 2, 2, 2, 0, 1, 0],
  [1, 1, 1, 2, 2, 0, 1, 0],
  [1, 1, 1, 2, 2, 2, 2, 0],
  [1, 1, 1, 1, 1, 2, 1, 1],
  [1, 1, 1, 1, 1, 2, 2, 1],
    ]

  m = len(screen)
  n = len(screen[0])

  x = 4
  y = 4

  fill_colour = screen[x][y]
  border_colour = 3

  boundary_fill(screen, m, n, x, y, fill_colour, border_colour)

  for i in range(m):
    for j in range(n):
      print(screen[i][j], end =' ')
    print()

main()

#Boundary Fill Algorithm

def is_valid(screen, m, n, x, y, border_colour, fill_colour):
  if(x<0 or x>=m or y<0 or y>= n or screen[x][y]!= fill_colour and screen [x][y] != border_colour):
    return False
  return True

def boundary_fill(screen, m, n, x, y, border_colour, fill_colour):
  queue = []
  queue.append([x, y])
  screen[x][y] = fill_colour

  while queue:

    current_pixel = queue.pop()
    x_position = current_pixel[0]
    y_position = current_pixel[1]

    if(is_valid(screen, m, n, x_position+1, y_position, border_colour, fill_colour)):
      screen[x_position+1][y_position] = fill_colour
      queue.append([x_position, y_position])

    if(is_valid(screen, m, n, x_position-1, y_position, border_colour, fill_colour)):
      screen[x_position-1][y_position] = fill_colour
      queue.append([x_position-1, y_position])

    if(is_valid(screen, m, n, x_position, y_position+1, border_colour, fill_colour)):
      screen[x_position][y_position+1] = fill_colour
      queue.append([x_position, y_position+1]) 

    if(is_valid(screen, m, n, x_position, y_position-1, border_colour, fill_colour)):
      screen[x_position][y_position+1] = fill_colour
      queue.append([x_position, y_position-1])
    

def main():
  screen =[
  [1, 1, 1, 1, 1, 1, 1, 1],
  [1, 1, 1, 1, 1, 1, 0, 0],
  [1, 0, 0, 1, 1, 0, 1, 1],
  [1, 2, 2, 2, 2, 0, 1, 0],
  [1, 1, 1, 2, 2, 0, 1, 0],
  [1, 1, 1, 2, 2, 2, 2, 0],
  [1, 1, 1, 1, 1, 2, 1, 1],
  [1, 1, 1, 1, 1, 2, 2, 1],
    ]

  m = len(screen)
  n = len(screen[0])

  x = 4
  y = 4

  border_colour = screen[x][y]
  fill_colour = 3

  boundary_fill(screen, m, n, x, y, border_colour, fill_colour)

  for i in range(m):
    for j in range(n):
      print(screen[i][j], end =' ')
    print()

main()